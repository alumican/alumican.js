{"version":3,"sources":["../src/alumican.multitouch/alm/multitouch/Multitouch.ts","../src/alumican.multitouch/alm/multitouch/MultitouchPointer.ts","../src/alumican.multitouch/alm/multitouch/MultitouchEvent.ts","../src/alumican.multitouch/alm/multitouch/TouchUtil.ts","../src/alumican.multitouch/index.ts"],"names":[],"mappings":"AAEA,kBAAU,GAAG,CAAC,UAAU,CAAC;IAIxB,MAAa,UAAW,SAAQ,WAAW;oBAQ9B,cAAa,WAAW,GAAG,MAAM,EAAE,iBAAe,WAAW,GAAG,MAAa;QAuBlF,KAAK,IAAG,IAAI;QAcZ,IAAI,IAAG,IAAI;QAcX,OAAO,IAAG,IAAI;QASrB,OAAO,CAAC,wBAAwB,CAoC9B;QAEF,OAAO,CAAC,uBAAuB,CAgB7B;QAEF,OAAO,CAAC,sBAAsB,CA0C5B;QAEF,OAAO,CAAC,eAAe;QAWvB,OAAO,CAAC,uBAAuB,CAkB7B;QAEF,OAAO,CAAC,uBAAuB,CAW7B;QAEF,OAAO,CAAC,qBAAqB,CAqB3B;QAEF,OAAO,CAAC,oBAAoB;QAKrB,aAAa,IAAG,OAAO;QAIvB,gBAAgB,IAAG,MAAM;QAIzB,qBAAqB,IAAG,MAAM,EAAE;QAIhC,kBAAkB,CAAC,WAAU,MAAM,GAAE,iBAAiB;QAItD,gBAAgB,IAAG,iBAAiB;QAIpC,gBAAgB,IAAG,iBAAiB;QAc3C,OAAO,CAAC,2BAA2B,CAAyB;QAC5D,OAAO,CAAC,kBAAkB,CAAU;QACpC,OAAO,CAAC,aAAa,CAAQ;QAC7B,OAAO,CAAC,UAAU,CAAS;QAE3B,OAAO,CAAC,QAAQ,CAAC,mBAAmB,CAAS;QAC7C,OAAO,CAAC,YAAY,CAAsB;QAC1C,OAAO,CAAC,cAAc,CAAsB;QAE5C,OAAO,CAAC,cAAc,CAAQ;QAC9B,OAAO,CAAC,MAAM,CAAC,cAAc,CAAa;KAC1C;CACD;AClSD,kBAAU,GAAG,CAAC,UAAU,CAAC;IAExB,MAAa,iBAAiB;oBAQjB,WAAU,MAAM,EAAE,IAAE,MAAU,EAAE,IAAE,MAAU;QA6BxD,SAAgB,SAAS,EAAC,MAAM,CAAC;QAC1B,UAAU,EAAC,OAAO,CAAC;QACnB,YAAY,EAAC,OAAO,CAAC;QACrB,WAAW,EAAC,OAAO,CAAC;QACpB,aAAa,EAAC,OAAO,CAAC;QACtB,aAAa,EAAC,OAAO,CAAC;QACtB,CAAC,EAAC,MAAM,CAAC;QACT,CAAC,EAAC,MAAM,CAAC;QACT,cAAc,EAAC,MAAM,CAAC;QACtB,YAAY,EAAC,MAAM,CAAC;QACpB,eAAe,EAAC,MAAM,CAAC;QACvB,eAAe,EAAC,MAAM,CAAC;KAC9B;CACD;ACpDD,kBAAU,GAAG,CAAC,UAAU,CAAC;IAExB,KAAY,mBAAmB;QAC9B,UAAU,eAAe;QACzB,SAAS,cAAc;QACvB,QAAQ,aAAa;KACrB;IAED,UAAiB,qBAAqB;QACrC,OAAO,EAAC,iBAAiB,CAAC;KAC1B;IAED,MAAa,eAAgB,SAAQ,WAAW,CAAC,qBAAqB,CAAC;oBAC1D,MAAK,mBAAmB,EAAE,SAAQ,eAAe,CAAC,qBAAqB,CAAC;KAGpF;CACD;ACjBD,kBAAU,GAAG,CAAC,UAAU,CAAC;IAExB,MAAa,SAAS;eAEP,wBAAwB,IAAG,OAAO;eAIlC,qBAAqB,CAAC,OAAM,KAAK,EAAE,OAAM,WAAW,GAAG,MAAM,GAAE;YAAE,OAAO,EAAC,MAAM,CAAC;YAAC,OAAO,EAAC,MAAM,CAAA;SAAE;eAIjG,gBAAgB,CAAC,SAAQ,MAAM,EAAE,SAAQ,MAAM,EAAE,OAAM,WAAW,GAAG,MAAM,GAAE;YAAE,OAAO,EAAC,MAAM,CAAC;YAAC,OAAO,EAAC,MAAM,CAAA;SAAE;QAa7H,OAAO;KAEP;CACD","file":"index.d.ts","sourcesContent":["/// <reference path=\"../../index.ts\" />\n\nnamespace alm.multitouch {\n\n\timport Hash = alm.util.Hash;\n\n\texport class Multitouch extends EventTarget {\n\n\t\t// --------------------------------------------------\n\t\t//\n\t\t// CONSTRUCTOR\n\t\t//\n\t\t// --------------------------------------------------\n\n\t\tconstructor(startHitArea:HTMLElement | Window, moveEndHitArea:HTMLElement | Window = null) {\n\t\t\tsuper();\n\n\t\t\tthis.startHitArea = startHitArea;\n\t\t\tthis.moveEndHitArea = moveEndHitArea || window;\n\t\t\tthis.isTouchEventEnabled = TouchUtil.getIsTouchEventSupported();\n\t\t\tthis.touchingPointersByPointerId = {};\n\t\t\tthis.touchingPointerIds = [];\n\t\t\tthis.touchingCount = 0;\n\n\t\t\tconsole.debug('[Multitouch] touchEvent enabled :', this.isTouchEventEnabled);\n\t\t}\n\n\n\n\n\n\t\t// --------------------------------------------------\n\t\t//\n\t\t// METHOD\n\t\t//\n\t\t// --------------------------------------------------\n\n\t\tpublic start():void {\n\t\t\tconsole.debug('[Multitouch] start');\n\n\t\t\tif (this.isTouchEventEnabled) {\n\t\t\t\tthis.startHitArea.addEventListener('touchstart', this.hitAreaTouchStartHandler);\n\t\t\t\tthis.moveEndHitArea.addEventListener('touchmove', this.hitAreaTouchMoveHandler);\n\t\t\t\tthis.moveEndHitArea.addEventListener('touchend', this.hitAreaTouchEndHandler);\n\t\t\t} else {\n\t\t\t\tthis.startHitArea.addEventListener('mousedown', this.hitAreaMouseDownHandler);\n\t\t\t\tthis.moveEndHitArea.addEventListener('mousemove', this.hitAreaMouseMoveHandler);\n\t\t\t\tthis.moveEndHitArea.addEventListener('mouseup', this.hitAreaMouseUpHandler);\n\t\t\t}\n\t\t}\n\n\t\tpublic stop():void {\n\t\t\tconsole.debug('[Multitouch] stop');\n\n\t\t\tif (this.isTouchEventEnabled) {\n\t\t\t\tthis.startHitArea.removeEventListener('touchstart', this.hitAreaTouchStartHandler);\n\t\t\t\tthis.moveEndHitArea.removeEventListener('touchmove', this.hitAreaTouchMoveHandler);\n\t\t\t\tthis.moveEndHitArea.removeEventListener('touchend', this.hitAreaTouchEndHandler);\n\t\t\t} else {\n\t\t\t\tthis.startHitArea.removeEventListener('mousedown', this.hitAreaMouseDownHandler);\n\t\t\t\tthis.moveEndHitArea.removeEventListener('mousemove', this.hitAreaMouseMoveHandler);\n\t\t\t\tthis.moveEndHitArea.removeEventListener('mouseup', this.hitAreaMouseUpHandler);\n\t\t\t}\n\t\t}\n\n\t\tpublic dispose():void {\n\t\t\tthis.stop();\n\t\t\tthis.startHitArea = null;\n\t\t\tthis.moveEndHitArea = null;\n\t\t\tthis.touchingPointersByPointerId = null;\n\t\t\tthis.touchingPointerIds = null;\n\t\t}\n\n\n\t\tprivate hitAreaTouchStartHandler = (event:TouchEvent):void => {\n\t\t\tfor (let pointerId in this.touchingPointersByPointerId) {\n\t\t\t\tconst pointer = this.touchingPointersByPointerId[pointerId];\n\t\t\t\tpointer.isLastTouch = false;\n\t\t\t\tpointer.isLatestTouch = false;\n\t\t\t}\n\n\t\t\tconst changedTouches = event.changedTouches;\n\t\t\tconst changedTouchCount = changedTouches.length;\n\t\t\tfor (let i = 0; i < changedTouchCount; ++i) {\n\t\t\t\tconst touch = changedTouches.item(i);\n\t\t\t\tconst pointer = this.getTouchPointer(touch);\n\t\t\t\tpointer.isTouching = true;\n\n\t\t\t\tconst localPosition = TouchUtil.getLocalTouchPosition(touch, this.startHitArea);\n\t\t\t\tpointer.x = localPosition.offsetX;\n\t\t\t\tpointer.y = localPosition.offsetY;\n\n\t\t\t\t// last touch\n\t\t\t\tif (i === changedTouchCount - 1) {\n\t\t\t\t\tpointer.isLastTouch = true;\n\t\t\t\t\tpointer.isLatestTouch = true;\n\t\t\t\t\tpointer.latestStartTime = performance.now();\n\t\t\t\t}\n\n\t\t\t\t// 0 touching -> 1 touching\n\t\t\t\tif (!this.isTouching && (this.touchingCount === 1)) {\n\t\t\t\t\tpointer.isFirstTouch = true;\n\t\t\t\t\tpointer.isOldestTouch = true;\n\t\t\t\t\tpointer.oldestStartTime = performance.now();\n\t\t\t\t}\n\n\t\t\t\tthis.isTouching = this.touchingCount > 0;\n\n\t\t\t\tthis.dispatchDefaultEvent(MultitouchEventType.touchStart, pointer);\n\t\t\t}\n\t\t};\n\n\t\tprivate hitAreaTouchMoveHandler = (event:TouchEvent):void => {\n\t\t\tif (this.touchingCount === 0) return;\n\n\t\t\tconst changedTouches = event.changedTouches;\n\t\t\tconst changedTouchCount = changedTouches.length;\n\t\t\tfor (let i = 0; i < changedTouchCount; ++i) {\n\t\t\t\tconst touch = changedTouches.item(i);\n\t\t\t\tconst pointer = this.getTouchPointer(touch);\n\t\t\t\tpointer.isTouching = true;\n\n\t\t\t\tconst localPosition = TouchUtil.getLocalTouchPosition(touch, this.startHitArea);\n\t\t\t\tpointer.x = localPosition.offsetX;\n\t\t\t\tpointer.y = localPosition.offsetY;\n\n\t\t\t\tthis.dispatchDefaultEvent(MultitouchEventType.touchMove, pointer);\n\t\t\t}\n\t\t};\n\n\t\tprivate hitAreaTouchEndHandler = (event:TouchEvent):void => {\n\t\t\tif (this.touchingCount === 0) return;\n\n\t\t\tconst changedTouches = event.changedTouches;\n\t\t\tconst changedTouchCount = changedTouches.length;\n\t\t\tfor (let i = 0; i < changedTouchCount; ++i) {\n\t\t\t\tconst touch = changedTouches.item(i);\n\t\t\t\tconst pointer = this.getTouchPointer(touch);\n\t\t\t\tpointer.isTouching = false;\n\t\t\t\tpointer.isOldestTouch = false;\n\t\t\t\tpointer.isLatestTouch = false;\n\n\t\t\t\tconst localPosition = TouchUtil.getLocalTouchPosition(touch, this.startHitArea);\n\t\t\t\tpointer.x = localPosition.offsetX;\n\t\t\t\tpointer.y = localPosition.offsetY;\n\n\t\t\t\tconst pointerIndex = this.touchingPointerIds.indexOf(pointer.pointerId);\n\t\t\t\tif (pointerIndex !== -1) {\n\t\t\t\t\tthis.touchingPointerIds.splice(pointerIndex, 1);\n\t\t\t\t\tthis.touchingCount = this.touchingPointerIds.length;\n\t\t\t\t}\n\t\t\t\tdelete this.touchingPointersByPointerId[pointer.pointerId];\n\t\t\t\tthis.isTouching = this.touchingCount > 0;\n\n\t\t\t\tthis.dispatchDefaultEvent(MultitouchEventType.touchEnd, pointer);\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tconst pointer = this.getOldestPointer();\n\t\t\t\tif (pointer && !pointer.isOldestTouch) {\n\t\t\t\t\tpointer.isOldestTouch = true;\n\t\t\t\t\tpointer.oldestStartTime = performance.now();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tconst pointer = this.getLatestPointer();\n\t\t\t\tif (pointer && !pointer.isLatestTouch) {\n\t\t\t\t\tpointer.isLatestTouch = true;\n\t\t\t\t\tpointer.latestStartTime = performance.now();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tprivate getTouchPointer(touch:Touch):MultitouchPointer {\n\t\t\tconst touchId = touch.identifier;\n\t\t\tlet pointer = this.touchingPointersByPointerId[touchId];\n\t\t\tif (!pointer) {\n\t\t\t\tpointer = this.touchingPointersByPointerId[touchId] = new MultitouchPointer(touchId);\n\t\t\t\tthis.touchingPointerIds.push(pointer.pointerId);\n\t\t\t\tthis.touchingCount = this.touchingPointerIds.length;\n\t\t\t}\n\t\t\treturn pointer;\n\t\t}\n\n\t\tprivate hitAreaMouseDownHandler = (event:MouseEvent):void => {\n\t\t\tthis.touchingCount = 1;\n\t\t\tthis.isTouching = true;\n\n\t\t\tthis.mousePointerId = ++Multitouch.mousePointerId;\n\n\t\t\tconst localPosition = TouchUtil.getLocalPosition(event.clientX, event.clientY, this.startHitArea);\n\t\t\tconst pointer = new MultitouchPointer(this.mousePointerId, localPosition.offsetX, localPosition.offsetY);\n\t\t\tpointer.isTouching = true;\n\t\t\tpointer.isFirstTouch = true;\n\t\t\tpointer.isLastTouch = true;\n\t\t\tpointer.isOldestTouch = true;\n\t\t\tpointer.isLatestTouch = true;\n\n\t\t\tthis.touchingPointersByPointerId[pointer.pointerId] = pointer;\n\t\t\tthis.touchingPointerIds.push(pointer.pointerId);\n\n\t\t\tthis.dispatchDefaultEvent(MultitouchEventType.touchStart, pointer);\n\t\t};\n\n\t\tprivate hitAreaMouseMoveHandler = (event:MouseEvent):void => {\n\t\t\tif (this.touchingCount === 0) return;\n\n\t\t\tconst pointer = this.touchingPointersByPointerId[this.mousePointerId];\n\t\t\tpointer.isTouching = true;\n\n\t\t\tconst localPosition = TouchUtil.getLocalPosition(event.clientX, event.clientY, this.startHitArea);\n\t\t\tpointer.x = localPosition.offsetX;\n\t\t\tpointer.y = localPosition.offsetY;\n\n\t\t\tthis.dispatchDefaultEvent(MultitouchEventType.touchMove, pointer);\n\t\t};\n\n\t\tprivate hitAreaMouseUpHandler = (event:MouseEvent):void => {\n\t\t\tif (this.touchingCount === 0) return;\n\t\t\tthis.touchingCount = 0;\n\t\t\tthis.isTouching = false;\n\n\t\t\tconst pointer = this.touchingPointersByPointerId[this.mousePointerId];\n\t\t\tpointer.isTouching = false;\n\t\t\tpointer.isOldestTouch = false;\n\t\t\tpointer.isLatestTouch = false;\n\t\t\tpointer.touchEndTime = performance.now();\n\n\t\t\tthis.mousePointerId = -1;\n\n\t\t\tconst localPosition = TouchUtil.getLocalPosition(event.clientX, event.clientY, this.startHitArea);\n\t\t\tpointer.x = localPosition.offsetX;\n\t\t\tpointer.y = localPosition.offsetY;\n\n\t\t\tdelete this.touchingPointersByPointerId[pointer.pointerId];\n\t\t\tthis.touchingPointerIds.pop();\n\n\t\t\tthis.dispatchDefaultEvent(MultitouchEventType.touchEnd, pointer);\n\t\t};\n\n\t\tprivate dispatchDefaultEvent(eventType:MultitouchEventType, pointer:MultitouchPointer):void {\n\t\t\tthis.dispatchEvent(new MultitouchEvent(eventType, { detail: { pointer: pointer } }));\n\t\t}\n\n\n\t\tpublic getIsTouching():boolean {\n\t\t\treturn this.isTouching;\n\t\t}\n\n\t\tpublic getTouchingCount():number {\n\t\t\treturn this.touchingCount;\n\t\t}\n\n\t\tpublic getTouchingPointerIds():number[] {\n\t\t\treturn this.touchingPointerIds.concat();\n\t\t}\n\n\t\tpublic getTouchingPointer(pointerId:number):MultitouchPointer {\n\t\t\treturn this.touchingPointersByPointerId[pointerId];\n\t\t}\n\n\t\tpublic getOldestPointer():MultitouchPointer {\n\t\t\treturn this.touchingCount > 0 ? this.touchingPointersByPointerId[this.touchingPointerIds[0]] : null;\n\t\t}\n\n\t\tpublic getLatestPointer():MultitouchPointer {\n\t\t\treturn this.touchingCount > 0 ? this.touchingPointersByPointerId[this.touchingPointerIds[this.touchingCount - 1]] : null;\n\t\t}\n\n\n\n\n\n\t\t// --------------------------------------------------\n\t\t//\n\t\t// MEMBER\n\t\t//\n\t\t// --------------------------------------------------\n\n\t\tprivate touchingPointersByPointerId:Hash<MultitouchPointer>;\n\t\tprivate touchingPointerIds:number[];\n\t\tprivate touchingCount:number;\n\t\tprivate isTouching:boolean;\n\n\t\tprivate readonly isTouchEventEnabled:boolean;\n\t\tprivate startHitArea:HTMLElement | Window;\n\t\tprivate moveEndHitArea:HTMLElement | Window;\n\n\t\tprivate mousePointerId:number;\n\t\tprivate static mousePointerId:number = -1;\n\t}\n}\n","/// <reference path=\"../../index.ts\" />\n\nnamespace alm.multitouch {\n\n\texport class MultitouchPointer {\n\n\t\t// --------------------------------------------------\n\t\t//\n\t\t// CONSTRUCTOR\n\t\t//\n\t\t// --------------------------------------------------\n\n\t\tconstructor(pointerId:number, x:number = 0, y:number = 0) {\n\t\t\tthis.pointerId = pointerId;\n\t\t\tthis.isTouching = false;\n\t\t\tthis.isFirstTouch = false;\n\t\t\tthis.isLastTouch = false;\n\t\t\tthis.isOldestTouch = false;\n\t\t\tthis.isLatestTouch = false;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.touchStartTime = performance.now();\n\t\t\tthis.touchEndTime = -1;\n\t\t\tthis.oldestStartTime = -1;\n\t\t\tthis.latestStartTime = -1;\n\t\t}\n\n\n\t\t// --------------------------------------------------\n\t\t//\n\t\t// METHOD\n\t\t//\n\t\t// --------------------------------------------------\n\n\n\t\t// --------------------------------------------------\n\t\t//\n\t\t// MEMBER\n\t\t//\n\t\t// --------------------------------------------------\n\n\t\tpublic readonly pointerId:number;\n\t\tpublic isTouching:boolean;\n\t\tpublic isFirstTouch:boolean;\n\t\tpublic isLastTouch:boolean;\n\t\tpublic isOldestTouch:boolean;\n\t\tpublic isLatestTouch:boolean;\n\t\tpublic x:number;\n\t\tpublic y:number;\n\t\tpublic touchStartTime:number;\n\t\tpublic touchEndTime:number;\n\t\tpublic oldestStartTime:number;\n\t\tpublic latestStartTime:number;\n\t}\n}\n","/// <reference path=\"../../index.ts\" />\n\nnamespace alm.multitouch {\n\n\texport enum MultitouchEventType {\n\t\ttouchStart = 'touchstart',\n\t\ttouchMove = 'touchmove',\n\t\ttouchEnd = 'touchend',\n\t}\n\n\texport interface MultitouchEventDetail {\n\t\tpointer:MultitouchPointer;\n\t}\n\n\texport class MultitouchEvent extends CustomEvent<MultitouchEventDetail> {\n\t\tconstructor(type:MultitouchEventType, options:CustomEventInit<MultitouchEventDetail>) {\n\t\t\tsuper(type, options);\n\t\t}\n\t}\n}\n","/// <reference path=\"../../index.ts\" />\n\nnamespace alm.multitouch {\n\n\texport class TouchUtil {\n\n\t\tpublic static getIsTouchEventSupported():boolean {\n\t\t\treturn (window.document['ontouchstart'] !== undefined) || (window.navigator.maxTouchPoints > 0);\n\t\t}\n\n\t\tpublic static getLocalTouchPosition(touch:Touch, local:HTMLElement | Window):{ offsetX:number, offsetY:number } {\n\t\t\treturn TouchUtil.getLocalPosition(touch.clientX, touch.clientY, local);\n\t\t}\n\n\t\tpublic static getLocalPosition(clientX:number, clientY:number, local:HTMLElement | Window):{ offsetX:number, offsetY:number } {\n\t\t\tif (local['getBoundingClientRect']) {\n\t\t\t\tconst rect = (<HTMLElement>local).getBoundingClientRect();\n\t\t\t\treturn { offsetX: clientX - window.scrollX - rect.left, offsetY: clientY - window.scrollY - rect.top };\n\t\t\t} else {\n\t\t\t\treturn { offsetX: clientX, offsetY: clientY };\n\t\t\t}\n\t\t}\n\n\n\n\n\n\t\tprivate constructor() {\n\t\t}\n\t}\n}\n","/* ---------- project dependencies ---------- */\n\n/// <reference types='alumican' />\n\n\n/* ---------- project scripts ---------- */\n\n/// <reference path=\"alm/multitouch/Multitouch.ts\" />\n/// <reference path=\"alm/multitouch/MultitouchPointer.ts\" />\n/// <reference path=\"alm/multitouch/MultitouchEvent.ts\" />\n/// <reference path=\"alm/multitouch/TouchUtil.ts\" />\n"]}